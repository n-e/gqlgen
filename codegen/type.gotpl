{{- range $type := .ReferencedTypes }}
	{{ with $type.UnmarshalFunc }}
		func (ec *executionContext) {{ . }}(ctx context.Context, v interface{}) ({{ $type.GO | ref }}, error) {
			{{- if and $type.IsNilable (not $type.GQL.NonNull) (not $type.IsPtrToPtr) }}
				if v == nil { return nil, nil }
			{{- end }}
			{{- if $type.IsPtrToSlice }}
				res, err := ec.{{ $type.Elem.UnmarshalFunc }}(ctx, v)
				return &res, graphql.ErrorOnPath(ctx, err)
			{{- else if $type.IsSlice }}
				var vSlice []interface{}
				if v != nil {
					vSlice = graphql.CoerceList(v)
				}
				var err error
				res := make([]{{$type.GO.Elem | ref}}, len(vSlice))
				for i := range vSlice {
					ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
					res[i], err = ec.{{ $type.Elem.UnmarshalFunc }}(ctx, vSlice[i])
					if err != nil {
						return nil, err
					}
				}
				return res, nil
			{{- else if and $type.IsPtrToPtr (not $type.Unmarshaler) (not $type.IsMarshaler) }}
				var pres {{ $type.Elem.GO | ref }}
				if v != nil {
					res, err := ec.{{ $type.Elem.UnmarshalFunc }}(ctx, v)
					if err != nil {
						return nil, graphql.ErrorOnPath(ctx, err)
					}
					pres = res
				}
				return &pres, nil
			{{- else }}
				{{- if $type.Unmarshaler }}
					{{- if $type.CastType }}
						{{- if $type.IsContext }}
							tmp, err := {{ $type.Unmarshaler | call }}(ctx, v)
						{{- else }}
							tmp, err := {{ $type.Unmarshaler | call }}(v)
						{{- end }}
						{{- if and $type.IsNilable $type.Elem }}
							res := {{ $type.Elem.GO | ref }}(tmp)
						{{- else}}
							res := {{ $type.GO | ref }}(tmp)
						{{- end }}
					{{- else}}
						{{- if $type.IsContext }}
							res, err := {{ $type.Unmarshaler | call }}(ctx, v)
						{{- else }}
							res, err := {{ $type.Unmarshaler | call }}(v)
						{{- end }}
					{{- end }}
					{{- if and $type.IsTargetNilable (not $type.IsNilable) }}
						return *res, graphql.ErrorOnPath(ctx, err)
					{{- else if and (not $type.IsTargetNilable) $type.IsNilable }}
						return &res, graphql.ErrorOnPath(ctx, err)
					{{- else}}
						return res, graphql.ErrorOnPath(ctx, err)
					{{- end }}
				{{- else if eq ($type.GO | ref) "map[string]interface{}" }}
					return v.(map[string]interface{}), nil
				{{- else if $type.IsMarshaler }}
					{{- if and $type.IsNilable $type.Elem }}
						var res = new({{ $type.Elem.GO | ref }})
					{{- else}}
						var res {{ $type.GO | ref }}
					{{- end }}
					{{- if $type.IsContext }}
						err := res.UnmarshalGQLContext(ctx, v)
					{{- else }}
						err := res.UnmarshalGQL(v)
					{{- end }}
					return res, graphql.ErrorOnPath(ctx, err)
				{{- else }}
					res, err := ec.unmarshalInput{{ $type.GQL.Name }}(ctx, v)
					{{- if $type.IsNilable }}
						return &res, graphql.ErrorOnPath(ctx, err)
					{{- else}}
						return res, graphql.ErrorOnPath(ctx, err)
					{{- end }}
				{{- end }}
			{{- end }}
		}
	{{- end }}

	{{ with $type.MarshalFunc }}
		func (ec *executionContext) {{ . }}(ctx context.Context, sel ast.SelectionSet, v []{{ $type.GO | ref }}) []graphql.Marshaler {
			{{- if $type.IsPtrToSlice }}
				return ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, *v)
			{{- else if $type.IsSlice }}
				{{- if not $type.GQL.NonNull }}
					// TODO: handle if there are nil elements in v
					// if v == nil {
					//	return graphql.Null
					// }
				{{- end }}
				flat := {{ $type.GO | ref }}{}
				for i := range v {
					flat = append(flat,v[i]...)
				}

				ret := make([]graphql.Marshaler, len(v))

				blah := ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, flat)

				flatPos := 0
				for i := range v {
					item := make(graphql.Array,len(v[i]))

					for j := range v[i] {
						item[j] = blah[flatPos+j]
					}
					ret[i] = item
					flatPos += len(v[i])
				}

				return ret
			{{- else if and $type.IsPtrToPtr (not $type.Unmarshaler) (not $type.IsMarshaler) }}
				// TODO
				//if v == nil {
				//	return graphql.Null
				//}
				return ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, *v)
			{{- else }}
				{{- if $type.IsNilable }}
					if v == nil {
						{{- if $type.GQL.NonNull }}
						//	if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
						//		ec.Errorf(ctx, "the requested element is null which the schema does not allow")
						//	}
						{{- end }}
						//return graphql.Null
					}
				{{- end }}
				{{- if $type.IsMarshaler }}
					{{- if $type.IsContext }}
						return graphql.WrapContextMarshaler(ctx, v)
					{{- else }}
						return v
					{{- end }}
				{{- else if $type.Marshaler }}
					{{- $v := "v[i]" }}
					{{- if and $type.IsTargetNilable (not $type.IsNilable) }}
						{{- $v = "&v[i]" }}
					{{- else if and (not $type.IsTargetNilable) $type.IsNilable }}
						{{- $v = "*v[i]" }}
					{{- end }}
					res := make([]graphql.Marshaler, len(v))
					for i := range v { 
					blah := {{ $type.Marshaler | call }}({{- if $type.CastType }}{{ $type.CastType | ref }}({{ $v }}){{else}}{{ $v }}{{- end }})
					{{- if $type.GQL.NonNull }}
						if blah == graphql.Null {
							if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
								ec.Errorf(ctx, "the requested element is null which the schema does not allow")
							}
						}
					{{- end }}
					{{- if $type.IsContext }}
						res[i] = graphql.WrapContextMarshaler(ctx, blah)
					{{- else }}
						res[i] = blah
					{{- end }}
					}
					return res
				{{- else }}
					{{ if not $type.IsNilable}}
					x := make([]*{{ $type.GO | ref }}, len(v))
					for i := range v {
						x[i] = &v[i]
					}
					return ec._{{$type.Definition.Name}}(ctx, sel, x)
					{{ else }}
					return ec._{{$type.Definition.Name}}(ctx, sel, v)
					{{end}}
				{{- end }}
			{{- end }}
		}
	{{- end }}
{{- end }}
